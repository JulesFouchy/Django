<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
			<meta name="author" content="Dejan D. M. Milosavljevic">
		<link rel="icon" href="../favicon.ico" type="image/ico">
		<title>Model</title>
	</head>
	<body>
		<h1 align="center">Model class</h1>

		<h3>TOC</h3>
		<ul>
			<li><a href="#Description">Description</a></li>
			<li><a href="#Declaration">Declaration</a></li>
			<li><a href="#Definition">Definition</a></li>
			<li><a href="#Members">Members</a>
				<ul>
					<li><a href="#Typedefs">Typedefs</a></li>
					<li><a href="#Functions">Functions</a></li>
					<li><a href="#Data">Data</a></li>
					<li><a href="#Constructors">Constructors</a></li>
					<li><a href="#Operators">Operators</a></li>
				</ul>
			</li>
			<li><a href="#Examples">Examples</a></li>
		</ul>
		<dl>
			<dt><h3><a name="Description">Description</a></h3></dt>
			<dd>All colors are alias of <code>model</code> for some specified <a href="./ns/category.html">category</a>.<br>
				Every color <a href="glossary.html#model">model</a>/<a href="glossary.html#format">format</a> can be instantiated by using of this class.
			</dd>
			<dt><h3><a name="Declaration">Declaration</a></h3></dt>
			<dd>
				<code>
					template&lt; typename category_name &gt;<br>
					&nbsp; class model;
				</code>
			</dd>

			<dt><h3><a name="Definition">Definition ( without implementation )</a></h3></dt>
		<dd>
<pre><code>
    template&lt; typename category_name &gt;
     class model
      {
       public:
        typedef category_name category_type;

        typedef  typename ::color:trait::index&lt; category_type&gt;::instance_type     index_type;
        typedef  <i>unspecified</i>     index_return_image_type;
        typedef  <i>unspecified</i>     index_input_const_type

        typedef  typename ::color:trait::component&lt; category_type&gt;::instance_type     component_type;
        typedef  <i>unspecified</i>     component_input_const_type;
        typedef  <i>unspecified</i>     component_return_const_type;

        typedef  typename ::color:trait::container&lt; category_type&gt;::instance_type     container_type;
        typedef  <i>unspecified</i>     container_return_const_type;
        typedef  <i>unspecified</i>     container_return_original_type;
        typedef  <i>unspecified</i>     container_input_const_type;

        typedef  typename ::color:trait::size&lt; category_type&gt;::instance_type     size_type;

        typedef  <i>unspecified</i>     set_return_type;

        typedef  model&lt; typename category_name &gt;     this_type;

                 model();

        explicit model( container_input_const_type container );

        template&lt; typename tag_name >
         explicit model( ::color::constant::base&lt; tag_name &gt; const&amp; constant );

        explicit model( std::initializer_list&lt;component_type&gt; const&amp; ilist );

        model( ::color::model&lt;category_type&gt; const&amp; that );

        template&lt; typename other_category_name &gt;
         explicit model( ::color::model&lt;other_category_name&gt; const&amp; that );

        template&lt; typename tag_name &gt;
         this_type &amp; operator=( ::color::constant::base&lt; tag_name &gt; const&amp; constant );

        template&lt; typename other_category_name &gt;
         this_type &amp; operator=( ::color::model&lt;other_category_name&gt; const&amp; that );

        component_return_const_type get( index_input_const_type index )const;

        template&lt; index_type index &gt;
         component_return_const_type get()const;

        set_return_type set( index_input_const_type index, component_input_const_type component );

        template&lt; index_type index &gt;
         set_return_type set( component_input_const_type component );

        component_return_const_type operator[]( index_input_const_type index )const;

        proxy_type                  operator[]( index_input_const_type index );

        container_return_const_type          container()const;

        container_return_original_type       container();

        void container( container_input_const_type container );

        static size_type       size();

        private:
          container_type m_container;
    };</code></pre>
			</dd>
			<dt><h3><a name="Members">Members</a></h3></dt>
			<dd>
				<dl>
					<dt><h4><a name="Typedefs">Typedefs</a></h4></dt>
					<dd>
					<dl>
						<dt><code>category_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Category of color. It's enclose model and format in one type. </dd>
								<dt>Definition</dt>
								<dd><code>typedef category_name category_type;</code></dd>
								<dt>See also</dt>
								<dd><a href="./ns/category.html">Categories</a></dd>
								<dt>Example</dt>
								<dd>
									std::cout  &lt;&lt; ::color::trait::bound&lt; ::rgb::&lt; double &gt;::category_type &gt;::maximum<0>( );
								</dd>
							</dl>
						</dd>
						<dt><code>component_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Type of component.</dd>
								<dt>Definition</dt>
								<dd>::color::trait::component&lt; category_type &gt;::instance_type</dd>
							</dl>
						</dd>
						<dt><code>index_input_const_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Type of index but constant and it ais always used as function parameter</dd>
								<dt>Definition</dt>
								<dd>::color::trait::index&lt; category_type &gt;::model_type</dd>
							</dl>
						</dd>
						<dt><code>index_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Unsigned like type used for iteratio/accesing color components.  </dd>
								<dt>Definition</dt>
								<dd>::color::trait::index&lt; category_type &gt;::instance_type</dd>
							</dl>
						</dd>
						<dt><code>component_input_const_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Type of component but constant and it ais always used as function parameter</dd>
								<dt>Definition</dt>
								<dd>::color::trait::component&lt; category_type &gt;::model_type</dd>
							</dl>
						</dd>
						<dt><code>component_return_const_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>This type is used when function return somponent</dd>
								<dt>Definition</dt>
								<dd>::color::trait::component&lt; category_type &gt;::return_const_type</dd>
							</dl>
						</dd>

						<dt><code>container_return_const_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Original but unmodifiable version of container</dd>
								<dt>Definition</dt>
								<dd>::color::trait::container&lt; category_type &gt;::return_const_type</dd>
							</dl>
						</dd>

						<dt><code>container_return_original_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Original container with unrestricted access. </dd>
								<dt>Definition</dt>
								<dd>::color::trait::container&lt; category_type &gt;::return_original_type</dd>
							</dl>
						</dd>

						<dt><code>container_input_const_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Input constant parameter. Usually constant reference. </dd>
								<dt>Definition</dt>
								<dd>::color::trait::container&lt; category_type &gt;::model_type</dd>
							</dl>
						</dd>

						<dt><code>index_return_image_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Type that will be returned</dd>
								<dt>Definition</dt>
								<dd> <code>typedef ::color:trait::container&lt; category_type&gt;::return_image_type index_return_image_type;</code> </dd>
							</dl>
						</dd>

						<dt><code>container_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Type of container. It is instanceable and modifiable.</dd>
								<dt>Definition</dt>
								<dd> <code>typedef ::color:trait::container&lt; category_type&gt;::instance_type container_type;</code> </dd>
								<dt>See also</dt>
								<dd><a href="./ns/trait.html">::color::trait::container&lt; category_type&gt;</a></dd>
							</dl>
						</dd>

						<dt><code>size_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Return type of size function.</dd>
								<dt>Definition</dt>
								<dd><code>typedef typename ::color:trait::size&lt; category_type&gt;::instance_type        size_type;</code></dd>
								<dt>Note</dt>
								<dd>Usually same as std::size_t.</dd>
							</dl>
						</dd>


						<dt><code>set_return_type</code></dt>
						<dd>
							<dl>
								<dt>Description</dt>
								<dd>Return type of set function.</dd>
								<dt>Definition</dt>
								<dd><code>typedef typename container_trait_type::set_return_type        set_return_type;</code></dd>
								<dt>Note</dt>
								<dd>Usually void.</dd>
							</dl>
						</dd>

						<dt><code>this_type</code></dt><dd>
							<dl>
								<dt>Description</dt>
								<dd>Same type as original type;</dd>
								<dt>Definition</dt>
								<dd><code>typedef  model&lt; typename category_name &gt;     this_type;</code></dd>
								<dt>Note</dt>
								<dd>Not recommended to use. Might be removed ins some next iteration.</dd>
							</dl>
						</dd>
					</dl>

					<dt><h4><a name="Constructors">Constructors</a></h4></dt>
					<dd>
						<dl>
							<dt>model();</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Empty constructor. Nothing will be done. No action will be performed. Internal data will NOT be initialized.</dd>
									<dt>Definition</dt>
									<dd><code>model();</code></dd>
								</dl>
							</dd>

							<dt>model( container )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Initialize color with container. Only one assignment of container class will be performed.</dd>
									<dt>Definition</dt>
									<dd><code>explicit model( container_input_const_type container );</code></dd>
								</dl>
							</dd>

							<dt>model( contant )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Initialize intanc with contant</dd>
									<dt>Definition</dt>
									<dd><code>template&lt; typename tag_name &gt;<br>&nbsp; &nbsp;explicit model( ::color::constant::base< tag_name > const&amp; constant );</code></dd>
								</dl>
							</dd>

							<dt>model( initializer_list )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Initialize instance with list.</dd>
									<dt>Definition</dt>
									<dd><code>explicit model( std::initializer_list<component_type> const& ilist );</code></dd>
								</dl>
							</dd>

							<dt>model(model)</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Copy constructor </dd>
									<dt>Definition</dt>
									<dd><code>model( ::color::model&lt;category_type&gt; const&amp that );</code></dd>
								</dl>
							</dd>

							<dt>model( other )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Copy constructor from another model.</dd>
									<dt>Definition</dt>
									<dd><code>template&lt; typename other_category_name &gt;<br>&nbsp; &nbsp;  explicit model( ::color::model&lt;other_category_name&gt; const&amp; that );</code></dd>
								</dl>
							</dd>
						</dl>
					</dd>

					<dt><h4><a name="Operators">Operators</a></h4></dt>
					<dd>
						<dl>

							<dt>operator=( constant )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Assign constant value to instance</dd>
									<dt>Definition</dt>
									<dd><code>template&lt; typename tag_name &gt; this_type &amp; operator=( ::color::constant::base&lt; tag_name &gt; const&amp; constant );</code></dd>
								</dl>
							</dd>

							<dt>operator=( model )</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Assign other color model to instance</dd>
									<dt>Definition</dt>
									<dd><code> template&lt; typename other_category_name &gt; this_type &amp; operator=( ::color::model&lt;other_category_name&gt; const&amp; that );</code></dd>
								</dl>
							</dd>
						</dl>
					</dd>

					<dt><h4><a name="Functions">Functions</a></h4></dt>
					<dd>
						<dl>
							<dt>get()const</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Get component for given index</dd>
									<dt>Definition</dt>
									<dd><code>component_return_const_type<br>&nbsp;&nbsp;get( index_input_const_type index )const </code></dd>
									<dt>Note</dt>
									<dd>This is version of get is slower then template.</dd>
								</dl>
							</dd>
							<dt>get&lt;index&gt;()const</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Get component for given index. Index will be get from template parameter.</dd>
									<dt>Definition</dt>
									<dd><code>template&lt; index_type index &gt;<br>&nbsp;component_return_const_type &nbsp;get()const;</code></dd>
								</dl>
							</dd>

							<dt>set</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Set component.</dd>
									<dt>Definition</dt>
									<dd><code>set_return_type&nbsp;&nbsp;set( index_input_const_type index, component_input_const_type component ) </code></dd>
									<dt>Note</dt>
									<dd>This version of <code>set</code> is slow in compare to template version.</dd>
								</dl>
							</dd>

							<dt>set&lt;index&gt;</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Set component value. Index come from template.</dd>
									<dt>Definition</dt>
									<dd><code>template&lt index_type index &gt;<br>&nbsp; set_return_type set( component_input_const_type component ) </code></dd>
									<dt>Note</dt>
									<dd>This version of <code>set</code> is faster and it is optimized to get only component for given index .</dd>
								</dl>
							</dd>

							<dt>operator[]const</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Return constant value of component.</dd>
									<dt>Definition</dt>
									<dd><code>component_return_const_type operator[]( index_input_const_type index )const </code></dd>
								</dl>
							</dd>

							<dt>operator[];</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Non-const modifiable version of <code>operator[]( index_input_const_type index )</code>. Modification of return value has effect on instance as using set function.</dd>
									<dt>Definition</dt>
									<dd><code>proxy_type operator[]( index_input_const_type index );</code></dd>
								</dl>
							</dd>

							<dt>container()const</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Return constant reference to container</dd>
									<dt>Definition</dt>
									<dd><code> container_return_const_type container()const </code></dd>
								</dl>
							</dd>

							<dt>container</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Return reference to container</dd>
									<dt>Definition</dt>
									<dd><code>container_return_original_type       container() </code></dd>
								</dl>
							</dd>

							<dt>container</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Set content new content of container</dd>
									<dt>Definition</dt>
									<dd><code>void container( container_input_const_type container );</code></dd>
								</dl>
							</dd>

							<dt>size</dt>
							<dd>
								<dl>
									<dt>Description</dt>
									<dd>Number of components</dd>
									<dt>Definition</dt>
									<dd><code>static size_type       size() </code></dd>
								</dl>
							</dd>

						</dl>

					</dd>
					<dt><h4><a name="Data">Data</a></h4></dt>
					<dd>
						<dl>
							<dt><code>m_container</code></dt>
							<dd>

								<dl>
									<dt>Description</dt>
									<dd>Serve to purpose to hold all colors data by respecting format.</dd>
									<dt>Note</dt>
									<dd>The one and only data member.</dd>
									<dt>type</dt>
									<dd><code>container_type</code></dd>
								</dl>

							</dd>

						</dl>

					</dd>
				</dl>
			</dd>

			<dt><h3><a name="Examples">Examples</a></h3></dt>
			<dd>
				<ul>
					<li><code>color::model&lt; color::category::rgb_float &gt; r; </code> Equal to: <code>color::rgb&lt;float&gt; r;</code> </li>
					<li><code>color::model&lt; color::category::hsl_uint8 &gt; h; </code> Equal to: <code>color::hsl&lt;std::uint8_t&gt; h;</code> </li>
				</ul>
			</dd>

		</dl>
		<hr>
	</body>
</html>



