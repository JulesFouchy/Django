struct Bezier {vec2 p1; vec2 p2; vec2 p3; vec2 p4;};
const uint nbCurves = 5;
Bezier curves[nbCurves] = {{vec2(-0.577481, -0.144781), vec2(-0.577481, -0.144781), vec2(-0.969456, 0.618807), vec2(-0.587662, 0.527176)}, {vec2(-0.587662, 0.527176), vec2(-0.205868, 0.435546), vec2(-0.297499, -0.541847), vec2(-0.124419, -0.165143)}, {vec2(-0.124419, -0.165143), vec2(0.048661, 0.211560), vec2(0.033389, 0.634079), vec2(-0.180415, 0.338825)}, {vec2(-0.180415, 0.338825), vec2(-0.394220, 0.043571), vec2(-0.989819, -0.781105), vec2(-0.628387, -0.801467)}, {vec2(-0.628387, -0.801467), vec2(-0.266955, -0.821829), vec2(0.170835, -0.496032), vec2(0.181016, -0.440035)}};
//? #version 430
//? struct Bezier {
//?     vec2 p1;
//?     vec2 p2;
//?     vec2 p3;
//?     vec2 p4;
//? };
//? const uint nbCurves = 1;
//? Bezier curves[nbCurves] = {{vec2(-1, -1), vec2(-1,  1), vec2( 0, -1), vec2( 0,  0)}};

uniform int u_NbOfParticles;
uniform float u_aspectRatio;
// Params
uniform int u_count;
uniform int u_intLR;
uniform int u_intUD;
uniform float u_wheel;
uniform float u_ctrlWheel;
uniform float u_shiftWheel;
uniform float u_altWheel;
// Random
uniform float u_seed;
uniform vec2 u_xySeed;
//? float rand(float id, float seed);

vec2 drawBezier(float t, Bezier bezier) {
    return      (1-t)*(1-t)*(1-t) * bezier.p1
         + 3. * (1-t)*(1-t)*t     * bezier.p2
         + 3. * (1-t)*t*t         * bezier.p3
         +      t*t*t             * bezier.p4;
}

layout(std430, binding=1) buffer restPositions {
   vec2 restPos[];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main(){
    uint gid = gl_GlobalInvocationID.x;

    if (gid < u_NbOfParticles) {
        uint nbPartPerCurve = u_NbOfParticles / nbCurves;
        uint idealNbPart = nbPartPerCurve * nbCurves;
        uint n = gid < idealNbPart ? gid : idealNbPart - (gid - idealNbPart + 1);
        uint id =       n / nbPartPerCurve;
        float t = float(n % nbPartPerCurve) / nbPartPerCurve;
        restPos[gid] = drawBezier(t, curves[id]);
    }
}