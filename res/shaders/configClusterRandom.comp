#version 430

uniform float u_AspectRatio;

uniform int u_NbOfParticles;
uniform int u_NbClusters;
uniform int u_Shape;

uniform float u_Radius;
uniform float u_SpiralRotationSpeed;

uniform float u_Seed;

uniform float a;
uniform vec2 v;
uniform vec2 xyOff;
uniform float delta;

layout(std430, binding=1) buffer restPositions {
   vec2 restPos[];
};

float rand(vec2 co){
  return 2.0 * fract(sin(dot(co.xy ,v)) * a) - 1.0;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main(){
    uint gid = gl_GlobalInvocationID.x;
    if (gid < u_NbOfParticles) {
        int clusterSize = u_NbOfParticles / u_NbClusters;
        int clusterID = min(int(gid) / clusterSize, u_NbClusters-1);
        float clusterCoord = (gid % clusterSize) / float(clusterSize);
        vec2 center = vec2(rand(vec2(clusterID*delta, u_Seed + xyOff.y)), rand(vec2(clusterID*delta, u_Seed + xyOff.x)));
        switch (u_Shape){
            case 0: // Circle
                restPos[gid] = center + u_Radius * vec2(cos(6.28*clusterCoord), sin(6.28*clusterCoord));
                break;
            case 1: // Spiral
                restPos[gid] = center + clusterCoord * u_Radius * vec2(cos(6.28*clusterCoord*u_SpiralRotationSpeed), sin(6.28*clusterCoord*u_SpiralRotationSpeed));
                break;
            case 2: // Star
                int nbBranches = 5;
                int nbPartPerBranch = clusterSize / nbBranches;
                int branchId = int(clusterCoord * nbPartPerBranch);
                float branchCoord = float(gid % nbPartPerBranch) / nbPartPerBranch;
                float angle = branchId * 6.18 / nbBranches;
                restPos[gid] = center + u_Radius * branchCoord * vec2(cos(angle), sin(angle));
                break;
        }
    }
}